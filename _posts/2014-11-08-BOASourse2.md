---
layout: post
title: "BOA源码笔记2"
description: ""
category: c&&c++
tags: []
---

接上文，继续分析主函数。

##drop_privs()##

首先看到如下结构体：

    struct passwd *passwdbuf;

passwd是UNIX系统下`pwd.h`的默认定义

    struct passwd {
    char*pw_name; /*user name */
    char*pw_passwd; /*user password */
    uid_t pw_uid; /*user id */
    gid_t pw_gid; /*group id */
    char*pw_gecos; /*real name */
    char*pw_dir; /*home directory */
    char*pw_shell; /*shell program */
    };

getuid函数获取当前的进程号。getpwuid函数通过用户的uid查找用户的passwd数据。
    
     if (getuid() == 0) { //当前进程拥有root权限时
        struct passwd *passwdbuf;
        passwdbuf = getpwuid(server_uid); //server_uid由哪里传递过来？
        if (passwdbuf == NULL) {
            DIE("getpwuid");
        } 

initgroups()用来从组文件(/etc/group)中读取一项组数据, 若该组数据的成员中有参数user时,便将参数group组识别码加入到此数据中。如果pw_gid中有pw_name，则把group组识别码加入到asswdbuf中。
    
    if (initgroups(passwdbuf->pw_name, passwdbuf->pw_gid) == -1) {
            DIE("initgroups");
    }

`setgid(server_gid)`和`setuid(server_uid)`用来设定权限[1]。

    if (setgid(server_gid) == -1) {
        DIE("setgid");
        }       
    if (setuid(server_uid) == -1) {
        DIE("setuid");
        }

这里一旦setgid，则进程会由root权限变为普通用户权限。

可以看出这个函数的作用就是drop privileges——降权的，如果以root身份运行程序，现在尝试放弃root身份，转为boa.conf配置文件中的身份。

----------------------------------------------------------------------

##setuid()函数的正确使用方法##
开始时，某个程序需要root权限完成一些工作，但后续的工作不需要root权限。可以将该可执行程序文件设置set_uid位，并使得该文件的属主为root。这样，普通用户执行这个程序时，进程就具有了root权限，当不再需要root权限时，调用setuid(getuid())恢复进程的实际用户ID和有效用户ID为执行该程序的普通用户的ID 。对于一些提供网络服务的程序，这样做是非常有必要的，否则就可能被攻击者利用，使攻击者控制整个系统。

回忆一下su命令的作用，可以发现su是一个 set_uid程序。执行一个设置了set_uid位的程序时，内核将进程的有效用户ID设置为文件属主的ID(root的ID)。而内核检查一个进程是否具有访问某权限时，是使用进程的有效用户ID来进行检查的。su程序的文件属主是root，普通用户运行su命令时，su进程的权限是root权限。

对于设置了set_uid位的可执行程序也要注意，尤其是对那些属主是root的更要注意。因为Linux系统中root用户拥有最高权力。黑客们往往喜欢寻找设置了set_uid位的可执行程序的漏洞。这样的程序如果存在缓冲区溢出漏洞，并且该程序是一个网络程序，那么黑客就可以从远程的地方轻松地利用该漏洞获得运行该漏洞程序的主机的root权限。即使这样的成不是网络程序，那么也可以使本机上的恶意普通用户提升为root权限。

APUE section4.4 Set-User-ID and Set-Group-ID一节专门论述了uid,GID的用法。

分析到这里似乎可以去了解一下手机root的原理了，[Android获取ROOT权限原理解析](http://blog.csdn.net/chaihuasong/article/details/8463212) 。甚至可以阅读一下 [su命令的源代码](http://download.csdn.net/detail/jinzhu117/4821630)。

-------------------------------------------------------------------

##守护进程##
    
    if (max_connections < 1) {
        struct rlimit rl;
    c = getrlimit(RLIMIT_NOFILE, &rl);
        if (c < 0) {
            perror("getrlimit");
            exit(1);
        }
        max_connections = rl.rlim_cur;
    }

getrlimit获取当前进程的资源限制，RLIMIT_NOFILE表示每个进程能打开的最大文件数。rlimit结构体包含两个变量，rlim_cur表示当前限制，rlim_max表示最大限制，硬限制。

    /* background ourself */
    if (do_fork) {
        switch(fork()) {
        case -1:
            /* error */
            perror("fork");
            exit(1);
            break;
        case 0:
            /* child, success */
            break;
        default:
            /* parent, success */
            exit(0);
            break;
        }

如果do_folk标志为1，则表示以守护进程方式运行。调用folk()后，父进程退出，子进程继续。到此为止，除了setsid，创建守护进程的其它规则都已经完成[4][5]。

----------------------------------------------------------------------

##select_loop##


--------------------------------------------------------------------

##Reference##
[1].http://blog.csdn.net/flagonxia/article/details/4041714

[2].http://blog.sina.com.cn/s/blog_701371290100yetd.html

[3].http://www.fookwood.com/archives/569

[4].APUE.Page 342

[5].http://tuzhii.com/2014/06/30/daemon/

