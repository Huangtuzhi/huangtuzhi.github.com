I"(<p>åŸºäºQTçš„QTcpServerç±»å®ç°ç®€å•çš„HTTPæœåŠ¡å™¨Tinyhttpdã€‚ä»£ç å­˜æ”¾åœ¨<a href="https://github.com/Huangtuzhi/Tinyhttpd">Github</a>ã€‚</p>

<hr />

<h2 id="qthreadå’Œqtimerè®¾ç½®">QThreadå’ŒQTimerè®¾ç½®</h2>

<p>å½“å­ç±»åŒ–QThreadæ—¶ï¼Œæ„é€ å‡½æ•°åœ¨æ—§çº¿ç¨‹ä¸­æ‰§è¡Œï¼Œç„¶è€Œrun()åœ¨æ–°çº¿ç¨‹ä¸­æ‰§è¡Œã€‚å¦‚æœä¸€ä¸ªæˆå‘˜å˜é‡çš„è®¿é—®æ¥è‡ªä¸¤ä¸ªå‡½æ•°ï¼Œç„¶åä»ä¸¤ä¸ªä¸åŒçš„çº¿ç¨‹è®¿é—®å˜é‡ï¼Œéœ€è¦æ£€æŸ¥è¿™æ ·åšæ˜¯å¦å®‰å…¨ã€‚</p>

<p>QTimerä¸èƒ½åœ¨ä¸€ä¸ªçº¿ç¨‹é‡Œå®ä¾‹åŒ–ï¼Œè€Œåœ¨å¦ä¸€ä¸ªçº¿ç¨‹startæˆ–è€…stopã€‚é‡‡å–çš„æ–¹æ³•æ˜¯ï¼š</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>QTimer* keep_alive_timer;

void Request::run()
{
    keep_alive_timer = new QTimer();
    if (s_keep_alive_enable)
    {
        keep_alive = s_keep_alive_default;
        keep_alive_timeout = s_keep_alive_timeout * 1000;// the wait time
        connect(keep_alive_timer,SIGNAL(timeout()),this,SLOT(onTimeout()));
        keep_alive_timer-&gt;setSingleShot(true);
        keep_alive_timer-&gt;setInterval(keep_alive_timeout);
        keep_alive_timer-&gt;start();
    }
    socket = new QTcpSocket();
    if (!socket-&gt;setSocketDescriptor(socketDescriptor))
        return;
    connect(socket, SIGNAL(readyRead()), this, SLOT(onReadyRead()), 
    Qt::DirectConnection);
    connect(socket, SIGNAL(disconnected()), this, SLOT(onDisconnected())ï¼Œ
    Qt::DirectConnection);
    exec();
}
</code></pre></div></div>
<hr />

<h2 id="qtäº‹ä»¶å¾ªç¯æœºåˆ¶">QTäº‹ä»¶å¾ªç¯æœºåˆ¶</h2>

<p>åœ¨ä¸Šé¢çš„run()ä¹‹åæœ‰ä¸€ä¸ªexec()å‡½æ•°ï¼Œå®ƒä¼šè¿›å…¥äº‹ä»¶å¾ªç¯ã€‚</p>

<p>Qtçš„äº‹ä»¶å¾ªç¯æ˜¯å¼‚æ­¥çš„ï¼Œå½“è°ƒç”¨QApplication::exec()æ—¶ï¼Œå°±è¿›å…¥äº†äº‹ä»¶å¾ªç¯ã€‚è¯¥å¾ªç¯å¯ä»¥ç®€åŒ–çš„æè¿°ä¸ºå¦‚ä¸‹çš„ä»£ç ï¼š</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>while ( !app_exit_loop )
{
   while( !postedEvents ) { processPostedEvents() }
   while( !qwsEvnts ){ qwsProcessEvents();   }
   while( !postedEvents ) { processPostedEvents() }
 
}
</code></pre></div></div>
<p>å…ˆå¤„ç†Qtäº‹ä»¶é˜Ÿåˆ—ä¸­çš„äº‹ä»¶ï¼Œç›´è‡³ä¸ºç©ºã€‚å†å¤„ç†ç³»ç»Ÿæ¶ˆæ¯é˜Ÿåˆ—ä¸­çš„æ¶ˆæ¯ï¼Œç›´è‡³ä¸ºç©ºã€‚åœ¨å¤„ç†ç³»ç»Ÿæ¶ˆæ¯çš„æ—¶å€™ä¼šäº§ç”Ÿæ–°çš„Qtäº‹ä»¶ï¼Œéœ€è¦å¯¹å…¶å†æ¬¡è¿›è¡Œå¤„ç†ã€‚</p>

<hr />

<h2 id="qtåƒåœ¾å›æ”¶æœºåˆ¶">QTåƒåœ¾å›æ”¶æœºåˆ¶</h2>

<p>åœ¨ç¨‹åºä¸­æœ‰å¾ˆå¤šåœ°æ–¹newäº†ä¸€ä¸ªå¯¹è±¡å¹¶æ²¡æœ‰deleteï¼Œè¿™æ ·ä¼šä¸ä¼šé€ æˆå†…å­˜æ³„æ¼å‘¢ã€‚</p>

<p>åœ¨QTä¸­ä¸ä¼šï¼Œå®ƒå®ç°äº†è‡ªå·±çš„GCæœºåˆ¶ã€‚</p>

<p>æ‰€æœ‰ç»§æ‰¿è‡ªQObjectç±»çš„ç±»ï¼Œå¦‚æœåœ¨newçš„æ—¶å€™æŒ‡å®šäº†çˆ¶äº²ï¼Œé‚£ä¹ˆå®ƒçš„æ¸…ç†æ˜¯åœ¨çˆ¶äº²è¢«deleteçš„æ—¶å€™ã€‚å¦‚æœä¸€ä¸ªç¨‹åºä¸­ï¼Œæ‰€æœ‰çš„QObjectç±»éƒ½æŒ‡å®šäº†çˆ¶äº²ï¼Œé‚£ä¹ˆä»–ä»¬æ˜¯ä¼šä¸€çº§çº§çš„åœ¨æœ€ä¸Šé¢çš„çˆ¶äº²æ¸…ç†æ—¶è¢«æ¸…ç†ã€‚æˆ‘ä»¬éœ€è¦æ˜¾å¼é‡Šæ”¾çš„æ˜¯é‚£äº›æ²¡æœ‰çˆ¶å¯¹è±¡çš„å­¤ç«‹çš„æŒ‡é’ˆå¯¹è±¡ã€‚</p>

<p>åƒä¸‡ä¸è¦åœ¨QTç±»çš„å­ç±»é‡Œå†™ææ„å‡½æ•°ï¼Œä¸è¦é—®æˆ‘ä¸ºä»€ä¹ˆçŸ¥é“ã€‚ä»Šå¤©å·²ç»è°ƒäº†ä¸€å¤©äº†ã€‚</p>

<hr />

<h2 id="å¤šç«¯å£ç›‘å¬å®ç°">å¤šç«¯å£ç›‘å¬å®ç°</h2>

<p>portçš„é…ç½®æ–‡ä»¶è¿™ä¹ˆå®šä¹‰</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[httpd]
port=1234|1235|1236|1237
</code></pre></div></div>
<p>è¯»å–é…ç½®</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>bool ok;
QString t_port = Settings::instance().value("httpd/port").toString();
QStringList port_list = t_port.split("|");

for(int i = 0; i &lt; port_list.size(); i++)
    {
        int port = port_list[i].toInt(&amp;ok,10);
        startInstance(port);
    }
    return true;
</code></pre></div></div>
<p>æ³¨æ„listen(QHostAddress::Any, 1234)æŒ‡ç›‘å¬ä»»ä½•è¿ä¸Š1234ç«¯å£çš„IPã€‚</p>

<hr />

<h2 id="incomingconnectionè™šå‡½æ•°">incomingConnectionè™šå‡½æ•°</h2>

<p>å®ƒæ˜¯ä¸€ä¸ªè™šå‡½æ•°ï¼Œå½“æœåŠ¡å™¨æ”¶åˆ°è¿æ¥è¯·æ±‚æ—¶ï¼Œå®ƒè¢«QTcpServerè°ƒç”¨ã€‚å®ƒåœ¨åº•å±‚åˆ›å»ºä¸€ä¸ªQTcpSocketï¼Œè®¾ç½®socketæè¿°ç¬¦å¹¶æŠŠæè¿°ç¬¦åŠ å…¥å†…éƒ¨çš„åˆ—è¡¨(å†…éƒ¨å¯èƒ½ç”¨selectè¿›è¡Œæ•°æ®å¼‚æ­¥è¯»å†™)ã€‚å½“é‡è½½è¿™ä¸ªå‡½æ•°æ—¶ï¼Œå¯ä»¥æ”¹å˜æœåŠ¡å™¨æ”¶åˆ°è¿æ¥è¯·æ±‚æ—¶çš„è¡Œä¸ºï¼Œç›¸å½“äºå®ç°äº†ä¸€ä¸ªhookã€‚è¿™æ ·å°±å¯ä»¥åœ¨è¿™ä¸ªå‡½æ•°é‡Œå®ç°httpæœåŠ¡å™¨ã€‚</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>void Server::incomingConnection(int socketDescriptor)
{
	//æœ‰æ–°çš„è¿æ¥æ—¶ï¼Œä»£æ›¿é»˜è®¤çš„åŠŸèƒ½ï¼ˆæ–°å»ºsocketï¼‰
    Request * request = new Request(socketDescriptor);
    request-&gt;start();
}

</code></pre></div></div>
<p>å¯è§socketæè¿°ç¬¦ä¼ åˆ°äº†Requestå®ä¾‹é‡Œï¼Œè¿™ä¸ªæè¿°ç¬¦å¯èƒ½æ˜¯å®ç°å¤šclientå¹¶å‘è¿æ¥çš„å…³é”®ã€‚</p>

<hr />

<h2 id="requestç±»">Requestç±»</h2>

<p>Requestæ˜¯QThreadçš„å­ç±»ï¼Œå®ƒå¯¹æ¯ä¸€ä¸ªæè¿°ç¬¦æ–°å»ºä¸€ä¸ªçº¿ç¨‹æ¥å¤„ç†å®ƒï¼Œå®è´¨å°±æ˜¯å¤„ç†æ¯ä¸ªclientçš„è¯·æ±‚ã€‚Requestç±»çš„æ ¸å¿ƒæ˜¯Request::run()ï¼Œå®ƒè¿˜å®ç°äº†incommingConnectionæ–°å»ºsocketçš„baseåŠŸèƒ½ï¼Œé€šè¿‡start()æ¥è¿›è¡Œè°ƒç”¨ã€‚</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>void Request::run()
{
    socket = new QTcpSocket();
    //ç”¨socketæè¿°ç¬¦ä½œä¸ºæ–°socketçš„æè¿°ç¬¦
    if (!socket-&gt;setSocketDescriptor(socketDescriptor))
        return;
    connect(socket, SIGNAL(readyRead()), this, SLOT(onReadyRead()),
    Qt::DirectConnection);
    exec();
}
</code></pre></div></div>
<p>è¿™ä¸ªå‡½æ•°é‡Œéœ€è¦ç”¨socketDescriptorä½œä¸ºæ–°QTcpSocketå¯¹è±¡çš„æè¿°ç¬¦ã€‚</p>

<blockquote>
  <p>If you want to handle an incoming connection as a new QTcpSocket object in another thread you have to pass the socketDescriptor to the other thread and create the QTcpSocket object there and use its setSocketDescriptor() method.</p>
</blockquote>

<p>æ³¨æ„è¿™ä¸ªå‡½æ•°çš„æœ€åä¸€è¡Œæ˜¯exec()ï¼Œä¼šè¿›å…¥äº‹ä»¶å¾ªç¯ï¼ŒServerThread::run()ä¸­ä¹Ÿæœ‰exec()å‡½æ•°ã€‚</p>

<p>å½“æ•°æ®å‡†å¤‡å¥½å¯è¯»çš„æ—¶å€™ï¼Œå†…æ ¸selectå‘å‡ºreadyRead()ä¿¡å·è§¦å‘onReadyRead()å‡½æ•°ã€‚è¿™æ ·çœ‹æ¥ï¼ŒonReadyRead()æ˜¯ä¸€è„‰ç›¸æ‰¿ä¸‹æ¥æœ€é‡è¦çš„å‡½æ•°ã€‚</p>

<hr />

<h2 id="onreadyreadå‡½æ•°">onReadyReadå‡½æ•°</h2>

<p>è¿™ä¸ªå‡½æ•°é‡Œå¼€å§‹è§£æclientå‘è¿‡æ¥çš„requestæ•°æ®ï¼Œå¹¶æ„é€ å°è£…responseæ•°æ®ã€‚</p>

<p>è¿™é‡Œæ˜¯ç”¨æµè§ˆå™¨æŠ“å–çš„æ ‡å‡†çš„Request Headerså’ŒResponse Headersã€‚</p>

<p><img src="/assets/images/httpserver-1.png" alt="å›¾ç‰‡" /></p>

<p><img src="/assets/images/httpserver-2.png" alt="å›¾ç‰‡" /></p>

<p>onReadyReadå‡½æ•°é‡Œçš„æ‰§è¡Œé¡ºåºå¦‚ä¸‹ï¼š</p>

<ol>
  <li>
    <p>getRequestHeader
è´Ÿè´£è¯»å–request headersï¼Œç¡®è®¤clientè¦æ±‚çš„æ˜¯é•¿\çŸ­è¿æ¥ã€‚</p>
  </li>
  <li>
    <p>tryResponseFile
è¿”å›è¯·æ±‚è·¯å¾„çš„ç›®å½•ï¼Œæœ‰4ç§æƒ…å†µã€‚ResponseDirectory()è¿”å›ç›®å½•;ç›´æ¥è¿”å›é¡µé¢;404;403</p>
  </li>
  <li>
    <p>ResonseFile
è°ƒç”¨response-&gt;responseè¿”å›ç½‘é¡µ</p>
  </li>
  <li>
    <p>clearStatus
å¦‚æœæ˜¯é•¿è¿æ¥ï¼ŒclearStatus()åç»§ç»­socketç›‘å¬ã€‚åŒæ—¶è®¡æ—¶ï¼Œå¦‚æœè¶…è¿‡timeoutåˆ™åˆ é™¤socketè¿æ¥ã€‚å¦‚æœæ˜¯çŸ­è¿æ¥ï¼Œç›´æ¥åˆ é™¤socketè¿æ¥ã€‚</p>
  </li>
</ol>

<hr />

<h2 id="çŠ¶æ€è®°å½•">çŠ¶æ€è®°å½•</h2>

<p>åŸºäºRedisçš„Cå®˜æ–¹å®¢æˆ·ç«¯hirediså°è£…ä¸€ä¸ªç±»Databaseï¼Œç”¨æ¥è®°å½•è®¿é—®çš„æ•°æ®ã€‚</p>

<p>å®‰è£…hiredis</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git clone https://github.com/antirez/hiredis.git &amp;&amp; cd hiredis 
make 
sudo make install 
sudo ldconfig
</code></pre></div></div>

<p>ä¸‹é¢å‘½ä»¤ç”¨æ¥è·å–è®¿é—®æ•°æ®</p>

<blockquote>
  <p>redis-cli -p 6378</p>
</blockquote>

<blockquote>
  <p>HMGET vistor:[n] time ip port agent</p>
</blockquote>

<hr />

<h2 id="ui-namespace">UI namespace</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>namespace Ui {
class MonitorUI;
}

class MonitorUI : public QMainWindow
{
    Q_OBJECT

public:
    explicit MonitorUI(QWidget *parent = 0);
    ~MonitorUI();
private:
    Ui::MonitorUI *ui;
};

</code></pre></div></div>
<p>å‰é¢<strong>å£°æ˜</strong>äº†ä¸€ä¸ªnamespace Uiï¼Œå®ƒæ˜¯ä¸€ä¸ªåŒ¿ååç§°ç©ºé—´ã€‚è¯¥namespace ä¸­çš„æˆå‘˜ï¼ˆå˜é‡æˆ–å‡½æ•°ï¼‰å…·æœ‰ç‹¬ä¸€æ— äºŒçš„å…¨å±€åç§°ï¼Œé¿å…åå­—ç¢°æ’ (name collisions)å®ƒçš„å®šä¹‰å­˜åœ¨äºè‡ªåŠ¨ç”Ÿæˆçš„ui_monitorui.hæ–‡ä»¶ä¸­</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>namespace Ui {
    class MonitorUI: public Ui_MonitorUI {};
} 
</code></pre></div></div>

<p>å› æ­¤Ui::MonitorUIå’ŒMonitorUIæ˜¯ä¸åŒçš„ä¸œè¥¿ã€‚</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>MonitorUI::MonitorUI(QWidget *parent) :
    QMainWindow(parent),
    ui(new Ui::MonitorUI)
{
    ui-&gt;setupUi(this);
}

</code></pre></div></div>
<p>å¯ä»¥çœ‹åˆ°uiæ˜¯Ui::MonitorUIçš„ä¸€ä¸ªå®ä¾‹ã€‚è°ƒç”¨setupUi(this)ã€‚</p>

<blockquote>
  <p>setupUi() creates the actual instances of widgets for you. A form that you create in QtDesigner is stored just as XML file. So to be able to build the actual â€œwindowâ€ with all the elements that you put on it in QtDesiner and display it in your application, setupUi() is created for you automatically by UIC (UI compiler - a Qt tool) so you donâ€™t have to do that manually.</p>
</blockquote>

<p>ä¸¤ä¸ªä¸€æ ·çš„ç±»åç”¨namespaceæ¥åŒºåˆ†å¼€ï¼Œå®ç°é€»è¾‘ä¸æ˜¾ç¤ºçš„åˆ†ç¦»(ç±»ä¼¼MVC)ã€‚</p>

<hr />

<h2 id="æ€»ç»“">æ€»ç»“</h2>

<p>Singleton Patternç”¨åœ¨æ—¥å¿—ç³»ç»Ÿå’Œé…ç½®ç³»ç»Ÿä¸­ï¼Œè¿™ä¸ªä¾‹å­ä¸­ä¸æ˜¯çº¿ç¨‹å®‰å…¨çš„ã€‚Singleton Patternçš„å®ä¾‹å…·æœ‰å’Œç¨‹åºä¸€æ ·çš„ç”Ÿå­˜æœŸ,å› ä¸ºinstanceæ˜¯newå‡ºæ¥çš„ï¼Œå®ƒä¸€ç›´å­˜åœ¨æ—¶ã€‚æ‰€ä»¥ææ„å‡½æ•°æ²¡æœ‰æœºä¼šè°ƒç”¨äº†ã€‚è¿™é‡Œä¼šäº§ç”Ÿmemory leakã€‚</p>

<hr />

<h2 id="reference">Reference</h2>
<p>[1].http://blog.chinaunix.net/uid-27685749-id-3847998.html</p>

<p>[2].http://www.linuxidc.com/Linux/2011-03/33810p2.htm</p>

<p>[3].http://blog.csdn.net/envenler/article/details/8020064</p>

<p>[4].http://blog.csdn.net/jandunlab/article/details/14108595</p>

<p>[5].http://blog.sina.com.cn/s/blog_a6fb6cc90101hohu.html</p>

<p>[6].http://qimo601.iteye.com/blog/1407911</p>

<p>[7].http://tuzhii.com/2015/03/19/dessignpattern/</p>

<p>[8].http://stackoverflow.com/questions/2496918/singleton-pattern-in-c</p>

<p>[9].http://blog.csdn.net/solstice/article/details/6186978</p>

:ET