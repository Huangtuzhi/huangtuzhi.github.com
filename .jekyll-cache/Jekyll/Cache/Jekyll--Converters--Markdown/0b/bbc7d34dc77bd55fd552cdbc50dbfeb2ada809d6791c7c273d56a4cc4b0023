I"<p>多任务可以用一个进程作为<code class="language-plaintext highlighter-rouge">Master</code>分配任务，其它进程作为<code class="language-plaintext highlighter-rouge">Worker</code>执行任务来实现。</p>

<p>这样可以把Master放在一台电脑上，Workers放在其他电脑上实现分布式。</p>

<hr />

<h2 id="master节点">Master节点</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#!/usr/bin/env python
#taskmanager.py
import random, time, Queue
from multiprocessing.managers import BaseManager

task_queue = Queue.Queue()
result_queue = Queue.Queue()

class QueueManager(BaseManager):
    pass

QueueManager.register('get_task_queue', callable=lambda: task_queue)
QueueManager.register('get_result_queue', callable=lambda: result_queue)

manager = QueueManager(address=('', 5000), authkey='abc')
manager.start()
task = manager.get_task_queue()
result = manager.get_result_queue()

for i in range(10):
    n = random.randint(0, 10000)
    print('Put task %d...' % n)
    task.put(n)
print('Try get results...')
 
for i in range(10):
    r = result.get(timeout=10)
    print('Result: %s' %r)
manager.shutdown()
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">task_queue</code>和<code class="language-plaintext highlighter-rouge">result_queue</code>是两个队列，分别存放任务和结果。<code class="language-plaintext highlighter-rouge">multiprocessing</code>库用来进行进程间通信(IPC)，交换对象。</p>

<p>官网上有如下例子。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>from multiprocessing import Process, Queuedef f(queue):
    queue.put([42, None, 'hello'])
    
if __name__ == '__main__':
    q = Queue()
    p = Process(target=f, args=(q,))
    p.start()
    print q.get()    # prints "[42, None, 'hello']"
    p.join()
</code></pre></div></div>

<p>其中p是一个进程，还有一个主进程。可以看到列表<code class="language-plaintext highlighter-rouge">[42, None, 'hello']</code>从p进程传到了主进程中。</p>

<p>因为是分布式的环境，放入queue中的数据需要等待Workers机器运算处理后再进行读取，这样就需要对queue用QueueManager进行封装放到网络中。这是通过</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>QueueManager.register('get_task_queue', callable=lambda: task_queue)
</code></pre></div></div>

<p>实现的。我们给<code class="language-plaintext highlighter-rouge">task_queue</code>的网络调用接口取了一个名字叫<code class="language-plaintext highlighter-rouge">get_task_queue</code>,而<code class="language-plaintext highlighter-rouge">result_queue</code>的名字是<code class="language-plaintext highlighter-rouge">get_result_queue</code>，方便区分对哪个queue进行操作。</p>

<p><code class="language-plaintext highlighter-rouge">task.put(n)</code>即是对<code class="language-plaintext highlighter-rouge">task_queue</code>进行写入数据，相当于分配任务。而<code class="language-plaintext highlighter-rouge">result.get()</code>即是等待workers处理后返回的结果。</p>

<hr />

<h2 id="worker节点">Worker节点</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#!/usr/bin/env 
#task_worker.py
import time, sys, Queue
from multiprocessing.managers import BaseManager

class QueueManager(BaseManager):
    pass

QueueManager.register('get_task_queue')
QueueManager.register('get_result_queue')

server_addr = '127.0.0.1'
print('Connect to server %s...' % server_addr)
m = QueueManager(address=(server_addr, 5000), authkey='abc')
m.connect()
task = m.get_task_queue()
result = m.get_result_queue()

for i in range(10):
    try:
        n = task.get(timeout=1)
        print('run task %d * %d...' % (n, n))
        r = '%d * %d = %d' % (n, n, n*n)
        time.sleep(1)
        result.put(r)
    except Queue.Empty:
        print('task queue is empty.')
print('worker exit.')
</code></pre></div></div>

<p>这里的<code class="language-plaintext highlighter-rouge">QueueManager</code>注册的名字必须和<code class="language-plaintext highlighter-rouge">task_manager</code>中的一样。注意到<code class="language-plaintext highlighter-rouge">taskworker.py</code>中根本没有创建Queue的代码，Queue对象存储在<code class="language-plaintext highlighter-rouge">taskmanager.py</code>进程中。对比上面的例子，可以看出Queue对象从另一个进程通过网络传递了过来。只不过这里的传递和网络通信由QueueManager完成。
<code class="language-plaintext highlighter-rouge">task_worker</code>的主要功能是将<code class="language-plaintext highlighter-rouge">task_queue</code>中分配的数据取出来进行平方运算然后放入到<code class="language-plaintext highlighter-rouge">result_queue</code>中。这样Master节点就能得到计算结果了。</p>

<hr />

<h2 id="测试结果">测试结果</h2>
<p>先运行<code class="language-plaintext highlighter-rouge">task_manager.py</code>如下</p>

<p><img src="/assets/images/DistributedProcess1.png" alt="图片" /></p>

<p>再运行<code class="language-plaintext highlighter-rouge">task_worker.py</code>如下</p>

<p><img src="/assets/images/DistributedProcess2.png" alt="图片" /></p>

<p>可以看到这里Workers对传过来的数据只是进行了简单的平方处理。这个简单的Manager/Worker模型有什么用？</p>

<p>其实这就是一个简单但真正的分布式计算，把代码稍加改造，启动多个worker，就可以把任务分布到几台甚至几十台机器上，比如把计算n*n的代码换成发送邮件，就实现了邮件队列的异步发送。或者可以利用多台机器求出N-皇后问题解的个数。</p>

<hr />

<h2 id="references">References</h2>

<p>[1].http://blog.csdn.net/fireroll/article/details/38895485</p>

<p>[2].http://www.jb51.net/article/58004.htm</p>

<p>[3].https://docs.python.org/3/library/multiprocessing.html?highlight=queuemanager</p>

<p>[4].http://www.zhihu.com/question/22608820</p>
:ET