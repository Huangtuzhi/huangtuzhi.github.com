I"H<p>Nginx有很多封装好的内部结构，实现诸如数组、链表、队列、哈希表等这样的容器。和STL一样，它们定义了自己的逻辑、功能及API。</p>

<hr />
<h2 id="ngx_array_t数组">ngx_array_t数组</h2>

<p><code class="language-plaintext highlighter-rouge">ngx_array_t</code>是nginx内部封装的使用<code class="language-plaintext highlighter-rouge">ngx_pool_t</code>对内存池进行分配的数组容器，其中的数据是在一整片内存区中连续存放的。更新数组时只能在尾部压入1个或多个元素,定义在<code class="language-plaintext highlighter-rouge">nginx/src/core/ngx_array.h</code>中。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>typedef struct {
    void        *elts;
    ngx_uint_t   nelts;
    size_t       size;
    ngx_uint_t   nalloc;
    ngx_pool_t  *pool;
} ngx_array_t;
</code></pre></div></div>

<p>其中<code class="language-plaintext highlighter-rouge">elts</code>指向数组元素所在的内存地址，<code class="language-plaintext highlighter-rouge">nelts</code>为实际元素个数，<code class="language-plaintext highlighter-rouge">size</code>是单个元素大小，<code class="language-plaintext highlighter-rouge">nalloc</code>为数组容量。</p>

<p><code class="language-plaintext highlighter-rouge">pool</code>指向要使用的实例化的内存池。</p>

<ul>
  <li>创建ngx_array_t数组</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ngx_array_t *
ngx_array_create(ngx_pool_t *p, ngx_uint_t n, size_t size)
{
    ngx_array_t *a;
    a = ngx_palloc(p, sizeof(ngx_array_t));
    if (a == NULL) {
        return NULL;
    }
    if (ngx_array_init(a, p, n, size) != NGX_OK) {
        return NULL;
    }
    return a;
}
</code></pre></div></div>
<p><code class="language-plaintext highlighter-rouge">a</code>是一个nginx数组指针，使用<code class="language-plaintext highlighter-rouge">p</code>指向的内存池分配内存。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>static ngx_int_t
ngx_array_init(ngx_array_t *array, ngx_pool_t *pool, ngx_uint_t n, size_t size)
{
    array-&gt;nelts = 0;
    array-&gt;size = size;
    array-&gt;nalloc = n;
    array-&gt;pool = pool;

    array-&gt;elts = ngx_palloc(pool, n * size);
    if (array-&gt;elts == NULL) {
        return NGX_ERROR;
    }

    return NGX_OK;
}
</code></pre></div></div>
<p>传进去实例化的内存池p、数组大小n和单个元素大小size。使用<code class="language-plaintext highlighter-rouge">ngx_array_init</code>来初始化数组，其中<code class="language-plaintext highlighter-rouge">array-&gt;elts</code>指向使用内存池p分配<code class="language-plaintext highlighter-rouge">n * size</code>大小的内存。</p>

<p>图示如下：</p>

<p><img src="/assets/images/nginx-1-2.png" alt="图片" /></p>

<ul>
  <li>删除ngx_array_t数组</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>void
ngx_array_destroy(ngx_array_t *a)
{
    ngx_pool_t  *p;
    p = a-&gt;pool;
    if ((u_char *) a-&gt;elts + a-&gt;size * a-&gt;nalloc == p-&gt;d.last) 
    {
        p-&gt;d.last -= a-&gt;size * a-&gt;nalloc;
    }
    if ((u_char *) a + sizeof(ngx_array_t) == p-&gt;d.last)    {
        p-&gt;d.last = (u_char *) a;
    }
</code></pre></div></div>
<p>数组删除分为两步，第一个<code class="language-plaintext highlighter-rouge">if</code>中将标示数组空内存起始地址的<code class="language-plaintext highlighter-rouge">last</code>更新到上图的<code class="language-plaintext highlighter-rouge">data(m)</code>结尾;第二个<code class="language-plaintext highlighter-rouge">if</code>中将<code class="language-plaintext highlighter-rouge">last</code>更新到上图的<code class="language-plaintext highlighter-rouge">ngx_pool_t</code>结尾。</p>

<ul>
  <li>ngx_array_push增加元素</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>void *
ngx_array_push(ngx_array_t *a)
{
    void        *elt, *new;
    size_t       size;
    ngx_pool_t  *p;

    if (a-&gt;nelts == a-&gt;nalloc) {
        //数组已满
        size = a-&gt;size * a-&gt;nalloc;
        p = a-&gt;pool;
        //当是最后一个元素且元素占的内存大小够
        if ((u_char *) a-&gt;elts + size == p-&gt;d.last
        &amp;&amp; p-&gt;d.last + a-&gt;size &lt;= p-&gt;d.end)
        {
            p-&gt;d.last += a-&gt;size;
            a-&gt;nalloc++;
        } else {
            //分配2倍的内存
            new = ngx_palloc(p, 2 * size);
            if (new == NULL) {
                return NULL;
            }
            //复制过来
            ngx_memcpy(new, a-&gt;elts, size);
            a-&gt;elts = new;
            a-&gt;nalloc *= 2;
        }
    }
    elt = (u_char *) a-&gt;elts + a-&gt;size * a-&gt;nelts;
    a-&gt;nelts++;
    return elt;
}
</code></pre></div></div>

<p>数组使用方法如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int main()
{
   int n;
   int* ele;
    //创建一个内存池
   ngx_pool_t* pool = ngx_create_pool(4000, NULL);
    //创建一个数组
   ngx_array_t* arr = ngx_array_create(pool, 10, sizeof(ngx_uint_t));;
   for (n=0; n &lt; 5; n++) {
      ele = (int*) ngx_array_push(arr);
      *ele = n;
      printf("new element %d added\n", n);
    }
}
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">ngx_array_push(arr)</code>在数组arr上新追加一个元素，并返回指向新元素的指针(<code class="language-plaintext highlighter-rouge">ele</code>)。需要把返回的指针使用类型转换，转换为具体的类型，然后再给新元素赋值<code class="language-plaintext highlighter-rouge">*ele = n</code>。</p>

<hr />

<p>##参考</p>

<p><a href="https://code.google.com/p/nginxsrp/wiki/NginxCodeReview">https://code.google.com/p/nginxsrp/wiki/NginxCodeReview</a></p>
:ET