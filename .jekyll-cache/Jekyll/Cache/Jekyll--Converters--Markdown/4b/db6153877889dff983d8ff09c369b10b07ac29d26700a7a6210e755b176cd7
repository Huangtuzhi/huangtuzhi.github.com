I"ø7<p>åœ¨linuxç³»ç»Ÿä¸­ï¼Œå•å¤„ç†å™¨ä¹Ÿæ˜¯å¤šçº¿ç¨‹å¤„ç†ä¿¡å·ã€äº‹ä»¶ç­‰ã€‚è¿™å°±éœ€è¦ä¸€ä¸ªæ ¸å¿ƒç®—æ³•æ¥è¿›è¡Œè¿›ç¨‹è°ƒåº¦ã€‚è¿™ä¸ªç®—æ³•å°±æ˜¯CFSï¼ˆCompletely Fair Schedulerï¼‰ã€‚åœ¨ <strong>LInux Kernel Development</strong> ä¸€ä¹¦ä¸­ç”¨ä¸€å¥è¯æ€»ç»“CFSè¿›ç¨‹è°ƒåº¦ï¼š</p>

<blockquote>
  <p>è¿è¡Œrbtreeæ ‘ä¸­æœ€å·¦è¾¹å¶å­èŠ‚ç‚¹æ‰€ä»£è¡¨çš„é‚£ä¸ªè¿›ç¨‹ã€‚</p>
</blockquote>

<p>åœ¨ä¸€ä¸ªè‡ªå¹³è¡¡äºŒå‰æœç´¢æ ‘çº¢é»‘æ ‘rbtreeçš„æ ‘èŠ‚ç‚¹ä¸­ï¼Œå­˜å‚¨äº†ä¸‹ä¸€ä¸ªåº”è¯¥è¿è¡Œè¿›ç¨‹çš„æ•°æ®ã€‚åœ¨è¿™é‡Œæˆ‘ä»¬çœ‹åˆ°äº†äºŒå‰æœç´¢æ ‘çš„å®Œç¾è¿ç”¨ã€‚å…·ä½“å¯å‚è§<strong>Introduction to Algorithms</strong> Page 174~182ã€‚</p>

<p>è€Œè¿›ç¨‹è°ƒåº¦çš„ä¸»è¦å…¥å£å‡½æ•°å°±æ˜¯schedule()ã€‚å®ƒå®šä¹‰åœ¨æ–‡ä»¶kernel/sched.cä¸­ã€‚</p>

<p>æˆ‘ä»¬å…ˆçœ‹ä¸€ä¸ªåœ¨ç­‰å¾…é˜Ÿåˆ—ä¸­è¿›è¡Œè¿›ç¨‹è°ƒåº¦çš„ä¾‹å­ï¼š</p>

<figure class="highlight"><pre><code class="language-objc" data-lang="objc">    <span class="n">DEFINE_WAIT</span><span class="p">(</span><span class="n">wait</span><span class="p">);</span> <span class="c1">//ç”³æ˜ç­‰å¾…é˜Ÿåˆ—</span>

    <span class="n">add_wait_queue</span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span class="o">&amp;</span><span class="n">wait</span><span class="p">);</span> <span class="c1">//æŠŠæˆ‘ä»¬ç”¨çš„qé˜Ÿåˆ—åŠ å…¥åˆ°waitç­‰å¾…é˜Ÿåˆ—ä¸­</span>
    <span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">condition</span><span class="p">){</span> <span class="c1">//å½“ç­‰å¾…äº‹ä»¶æ²¡æœ‰æ¥ä¸´æ—¶</span>
         <span class="n">prepare_to_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="p">,</span><span class="o">&amp;</span><span class="n">wait</span><span class="p">,</span><span class="n">TASK_INTERRUPTIBLE</span><span class="p">);</span>
         <span class="c1">//å°†qä»TASK_RUNNINGæˆ–è€…å…¶ä»–çŠ¶æ€ç½®ä¸ºTASK_INTERRUPTIBLEä¸å¯è¿è¡Œçš„ä¼‘çœ çŠ¶æ€ã€‚</span>
         <span class="c1">//åŒæ—¶æ¥å—ä¿¡å·&amp;&amp;äº‹ä»¶æ¥å”¤é†’å®ƒ</span>
         <span class="k">if</span><span class="p">(</span><span class="n">signal_pending</span><span class="p">(</span><span class="n">current</span><span class="p">))</span>  <span class="c1">//å¦‚æœæœ‰æ¥è‡ªä»å¤„ç†å™¨çš„ä¿¡å·</span>
         <span class="p">{</span> <span class="n">processingsignal</span><span class="p">();}</span><span class="c1">//å¤„ç†ä¿¡å·</span>
         <span class="n">schedule</span><span class="p">();</span> <span class="c1">//è°ƒç”¨çº¢é»‘æ ‘ä¸­çš„ä¸‹ä¸€ä¸ªè¿›ç¨‹</span>
    <span class="p">}</span>
    <span class="n">finish_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="p">,</span><span class="o">&amp;</span><span class="n">wait</span><span class="p">);</span> <span class="c1">//å°†è¿›ç¨‹è®¾ç½®ä¸ºTASK_RUNNINGå¹¶ç§»å‡ºç­‰å¾…é˜Ÿåˆ—.</span></code></pre></figure>

<p>å…¶å®æˆ‘ä»¬å¯ä»¥è¿™ä¹ˆç†è§£è¿™æ®µä»£ç ã€‚ç°åœ¨æœ‰ä¸€ä¸ªä»»åŠ¡è¦ç­‰å¾…äº‹ä»¶åˆ°æ¥æ‰èƒ½è¿è¡Œï¼Œæ€ä¹ˆå®ç°å‘¢ï¼Ÿå°±æ˜¯é˜»å¡åŠ æŸ¥è¯¢ã€‚ä½†æ˜¯è¿™æ ·ä¼šä½¿å¾—è¿™æ®µä»£ç ç‹¬å æ•´ä¸ªæ“ä½œç³»ç»Ÿã€‚ä¸ºäº†è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œå°±åœ¨é˜»å¡æŸ¥è¯¢ä¹‹ä¸­åŠ å…¥äº†é˜Ÿåˆ—å’Œè¿›ç¨‹è°ƒåº¦schedule()ï¼Œä»è€Œä¸è€½è¯¯å…¶å®ƒçº¿ç¨‹çš„æ‰§è¡Œã€‚</p>

<p>å†æ¥çœ‹ä¸€çœ‹schedule()å‡½æ•°çš„ç»“æ„ï¼š</p>

<hr />
<h2 id="scheduleå‡½æ•°ç»“æ„">schedule()å‡½æ•°ç»“æ„</h2>

<figure class="highlight"><pre><code class="language-objc" data-lang="objc"> 
    <span class="n">asmlinkage</span> <span class="kt">void</span> <span class="n">__sched</span> <span class="nf">schedule</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>  <span class="c1">///å®šä¹‰é€šè¿‡å †æ ˆä¼ å€¼</span>
    <span class="p">{</span>
    <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">prev</span><span class="p">,</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">switch_count</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>

    <span class="cm">/*At the end of this function, it will check if need_resched() return
    true, if that indeed happen, then goto here.*/</span>
    <span class="nl">need_resched:</span>

    <span class="cm">/*current process won't be preempted after call preemept_disable()*/</span>
    <span class="n">preempt_disable</span><span class="p">();</span> <span class="c1">//ä¸è®©ä¼˜å…ˆå æœ‰å½“å‰è¿›ç¨‹</span>
    <span class="n">cpu</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span>
    <span class="n">rq</span> <span class="o">=</span> <span class="n">cpu_rq</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
    <span class="cm">/* rcu_sched_qs ? */</span>
    <span class="n">rcu_sched_qs</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>

    <span class="cm">/* prev point to current task_struct */</span>
    <span class="n">prev</span> <span class="o">=</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">curr</span><span class="p">;</span>

    <span class="cm">/* get current task_struct's context switch count */</span>
    <span class="n">switch_count</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">nivcsw</span><span class="p">;</span>

    <span class="cm">/* kernel_flag is "the big kernel lock". 
     * This spinlock is taken and released recursively by lock_kernel()
     * and unlock_kernel(). It is transparently dropped and reacquired
     * over schedule(). It is used to protect legacy code that hasn't
     * been migrated to a proper locking design yet.
     * In task_struct, there is a member lock_depth, which is inited -1,
     * indicates that the current task have no kernel lock.
     * When lock_depth &gt;=0 indicate that it own kernel lock.
     * During context switching, it is not permitted that the task  
     * switched away remain own kernel lock , so in scedule(),it
     * call release_kernel_lock(), release kernel lock.
     */</span>
    <span class="n">release_kernel_lock</span><span class="p">(</span><span class="n">prev</span><span class="p">);</span>

    <span class="nl">need_resched_nonpreemptible:</span>

    <span class="n">schedule_debug</span><span class="p">(</span><span class="n">prev</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">sched_feat</span><span class="p">(</span><span class="n">HRTICK</span><span class="p">))</span>
        <span class="n">hrtick_clear</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>

    <span class="cm">/* occupy current rq's lock */</span>
    <span class="n">raw_spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span> <span class="c1">//å æœ‰rqè‡ªæ—‹é”</span>

    <span class="cm">/* update rq's clock,this function will call sched_clock_cpu() */</span>
    <span class="n">update_rq_clock</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>

    <span class="cm">/* clear bit in task_struct's thread_struct's flag TIF_NEED_RESCHED.
     * In case that it will be rescheduled, because it prepare to give
     * up cpu.
     */</span>
    <span class="n">clear_tsk_need_resched</span><span class="p">(</span><span class="n">prev</span><span class="p">);</span>



    <span class="k">if</span> <span class="p">(</span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">preempt_count</span><span class="p">()</span> <span class="o">&amp;</span> <span class="n">PREEMPT_ACTIVE</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">signal_pending_state</span><span class="p">(</span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">,</span> <span class="n">prev</span><span class="p">)))</span>
            <span class="n">prev</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">TASK_RUNNING</span><span class="p">;</span>
        <span class="k">else</span>
            <span class="n">deactivate_task</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">prev</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
        <span class="n">switch_count</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">nvcsw</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/* For none-SMP, pre_schedule is NULL */</span>
    <span class="n">pre_schedule</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">prev</span><span class="p">);</span>

  
    <span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">nr_running</span><span class="p">))</span>
        <span class="n">idle_balance</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">rq</span><span class="p">);</span>

    <span class="n">put_prev_task</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">prev</span><span class="p">);</span>


    <span class="n">next</span> <span class="o">=</span> <span class="n">pick_next_task</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>


    <span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">prev</span> <span class="o">!=</span> <span class="n">next</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">sched_info_switch</span><span class="p">(</span><span class="n">prev</span><span class="p">,</span> <span class="n">next</span><span class="p">);</span>
        <span class="n">perf_event_task_sched_out</span><span class="p">(</span><span class="n">prev</span><span class="p">,</span> <span class="n">next</span><span class="p">);</span>

        <span class="n">rq</span><span class="o">-&gt;</span><span class="n">nr_switches</span><span class="o">++</span><span class="p">;</span>
        <span class="n">rq</span><span class="o">-&gt;</span><span class="n">curr</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
        <span class="o">++*</span><span class="n">switch_count</span><span class="p">;</span>

        <span class="n">context_switch</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">prev</span><span class="p">,</span> <span class="n">next</span><span class="p">);</span> <span class="cm">/* unlocks the rq */</span>
        <span class="cm">/*
         * the context switch might have flipped the stack from under
         * us, hence refresh the local variables.
         */</span>
        <span class="n">cpu</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span>
        <span class="n">rq</span> <span class="o">=</span> <span class="n">cpu_rq</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span>
      <span class="n">raw_spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span><span class="c1">//current task still occupy cpu</span>

    <span class="n">post_schedule</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">reacquire_kernel_lock</span><span class="p">(</span><span class="n">current</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">prev</span> <span class="o">=</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">curr</span><span class="p">;</span>
        <span class="n">switch_count</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">nivcsw</span><span class="p">;</span>
        <span class="k">goto</span> <span class="n">need_resched_nonpreemptible</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">preempt_enable_no_resched</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">need_resched</span><span class="p">())</span>
        <span class="k">goto</span> <span class="n">need_resched</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">schedule</span><span class="p">);</span></code></pre></figure>

<p>schedule()å‡½æ•°çš„ç›®çš„åœ¨äºç”¨å¦ä¸€ä¸ªè¿›ç¨‹æ›¿æ¢å½“å‰æ­£åœ¨è¿è¡Œçš„è¿›ç¨‹ã€‚å› æ­¤ï¼Œè¿™ä¸ªå‡½æ•°çš„ä¸»è¦ç»“æœå°±æ˜¯è®¾ç½®ä¸€ä¸ªåä¸ºnextçš„å˜é‡ï¼Œä»¥ä¾¿å®ƒæŒ‡å‘æ‰€é€‰ä¸­çš„ ä»£æ›¿currentçš„è¿›ç¨‹çš„æè¿°ç¬¦ã€‚å¦‚æœåœ¨ç³»ç»Ÿä¸­æ²¡æœ‰å¯è¿è¡Œè¿›ç¨‹çš„ä¼˜å…ˆçº§å¤§äºcurrentçš„ä¼˜å…ˆçº§ï¼Œé‚£ä¹ˆï¼Œç»“æœæ˜¯nextä¸currentä¸€è‡´ï¼Œæ²¡æœ‰è¿›ç¨‹åˆ‡æ¢å‘ç”Ÿã€‚</p>

<hr />
<h2 id="references">References</h2>

<p>[1].UNDERSTANDING THE LINUX KERNEL. Page 276</p>

<p>[2].Linux Kernel Development. Page 52</p>

<p>[3].http://hi.baidu.com/zengzhaonong/item/20d9e8207b04cb8f6e2cc323</p>
:ET