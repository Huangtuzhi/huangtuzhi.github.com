I"M<p>C++ Primer 12章动态内存中定义了一个StrBlob类，它实现了一个新的集合类型，和vector类似。这么定义可以允许多个对象共享相同的元素，其实实质就是浅拷贝，而vector是深拷贝。下面借助这个类实现一下迭代器。用StrBlob存入一个文件的每行，用StrblobPtr迭代器打印每个元素。</p>

<hr />

<p>##StrBlob类</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class StrBlob
{
    friend class StrBlobPtr;
public:
    StrBlob(): data(make_shared&lt;vector&lt;string&gt;&gt;()) { }
    StrBlob(initializer_list&lt;string&gt; il): 
        data(make_shared&lt;vector&lt;string&gt;&gt;(il)) { }
    int size() const { return data-&gt;size(); }
    bool empty() const { return data-&gt;empty(); }
    void push_back(const string&amp; t) { data-&gt;push_back(t); }
    void pop_back();

    string&amp; front();
    string&amp; back();

    StrBlobPtr begin();
    StrBlobPtr end();
private:
    shared_ptr&lt;vector&lt;string&gt;&gt; data;
    void check(int i, const string&amp; msg) const;
};

StrBlobPtr StrBlob::begin() 
{
    return StrBlobPtr(*this); 
}

StrBlobPtr StrBlob::end()
{
    return StrBlobPtr(*this, data-&gt;size()); 
}

</code></pre></div></div>
<p>StrBlobPtr作为迭代器，为了使StrBlobPtr能访问StrBlob的私有成员data，将它定义为friend。</p>

<p>data是指向vector<string>的指针，用来保存元素。</string></p>

<hr />

<p>##StrBlobPtr类</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class StrBlobPtr
{
public:
    StrBlobPtr(): curr(0){ }
    StrBlobPtr(StrBlob &amp;a, size_t sz = 0):
            wptr(a.data), curr(sz) { }
    string&amp; deref() const;
    StrBlobPtr&amp; incr();
private:
    shared_ptr&lt;vector&lt;string&gt;&gt; check(size_t i, const string&amp; msg) const;
    weak_ptr&lt;vector&lt;string&gt;&gt; wptr;
    size_t curr;
};

string&amp; StrBlobPtr::deref() const
{
    auto p = check(curr, "dereference past end");
    return (*p)[curr];
}

StrBlobPtr&amp; StrBlobPtr::incr()
{
    check(curr, "increment past end of StrBlobPtr");
    ++curr;
    return *this;
}

</code></pre></div></div>
<p>StrBlobPtr有两个构造函数，第一个默认构造函数生成空的StrBlobPtr，初始化列表将curr显示初始化为0，将wptr隐式初始化为空的weak_ptr。</p>

<p>第二个构造函数接受一个StrBlob引用和一个可选的索引值(有默认参数，所以可以不写)，wptr被绑定到StrBlob的shared_ptr指针上，对元素具有访问权了。</p>

<p>我们观察StrBlob的成员函数StrBlob::begin()，发现它返回StrBlobPtr类。StrBlobPtr(*this)调用构造函数，因为有默认参数，所以调用的是第二个构造函数，相当于StrBlobPtr(*this， 0)[1]。同理StrBlob::end()也调用这个构造函数，只不过它的curr指向vector的末尾。</p>

<p>现在打印出StrBlob的所有元素</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>StrBlob Blob;
StrBlobPtr ptr;
for(int i=0; i&lt;Blob.size(); i++){
	ptr = ptr.incr();
	cout &lt;&lt; ptr.deref()&lt;&lt; endl;
}
</code></pre></div></div>

<p>其中incr()用来增加索引，deref()用来解引用取值。这和标准的vector是不是很像?</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>vector&lt;int&gt;::iterator iter;
for(iter=vi.begin();iter!=vi.end();++iter)
    cout&lt;&lt;*iter;   
</code></pre></div></div>
<p>但是还差一些，我们需要重载++，!=，*这三个运算符。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>StrBlobPtr&amp; operator ++(int) { this-&gt;curr++; }
bool operator !=(const StrBlobPtr&amp; rhs){
    return (this-&gt;curr != rhs.curr);
}
string&amp; operator *(){
    auto p = check(curr, "dereference past end");
    return (*p)[curr];
}
</code></pre></div></div>

<p>这样上述遍历代码可以写为</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>StrBlobPtr iter;
for(iter=Blob.begin(); iter!=Blob.end(); iter++){
cout &lt;&lt; *iter &lt;&lt; '\n';
</code></pre></div></div>

<p>++实现incr()的功能，*实现deref()的功能。</p>

<p>需要注意++的重载，StrBlobPtr&amp; operator ++(int)加入int表示是后++的重载，而StrBlobPtr&amp; operator ++()表示前++的重载。[2]</p>

<p>这样就实现了StrBlob类的迭代器，完整的实现代码放在<a href="https://github.com/Huangtuzhi/CppPrimer/blob/master/ch12/ex12_20.cpp">Github</a>。</p>

<p>输出结果如下:</p>

<p><img src="/assets/images/iteratorpattern1.png" alt="图片" /></p>

<blockquote>
  <p>谁此时没有房子，就不必建造，</p>
</blockquote>

<blockquote>
  <p>谁此时孤独，就永远孤独，</p>
</blockquote>

<blockquote>
  <p>就醒来，读书，写长长的信，</p>
</blockquote>

<blockquote>
  <p>在林荫路上不停地</p>
</blockquote>

<blockquote>
  <p>徘徊，落叶纷飞</p>
</blockquote>

<hr />

<p>##Reference
[1].http://stackoverflow.com/questions/29867449/how-smart-pointer-weak-ptr-is-bound-to-shared-ptr-in-this-case</p>

<p>[2].http://blog.csdn.net/ozwarld/article/details/8263868</p>

<p>[3].http://blog.csdn.net/vipygd/article/details/18746867</p>
:ET