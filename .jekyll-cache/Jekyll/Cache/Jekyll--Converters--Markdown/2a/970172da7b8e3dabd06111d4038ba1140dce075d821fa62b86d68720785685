I"s<p>æ“ä½œç³»ç»Ÿç®¡ç†å†…å­˜ä¸­çš„ç‰©ç†é¡µé¢ï¼Œæ‹…ä»»ç€å†…å­˜åˆ†é…çš„èŒè´£ã€‚åº”ç”¨ç¨‹åºå¯ä»¥é€šè¿‡ç±»ä¼¼mallocçš„å‡½æ•°å‘æ“ä½œç³»ç»Ÿç”³è¯·ç‰©ç†é¡µé¢ã€‚åœ¨ä½¿ç”¨å®Œç‰©ç†é¡µé¢ä¹‹åï¼Œé€šè¿‡ç±»ä¼¼deleteçš„é‡Šæ”¾å‡½æ•°é‡Šæ”¾è¿™äº›é¡µé¢ã€‚</p>

<p>ä½†æ˜¯æœ‰äº›ç‰©ç†é¡µé¢æ— æ³•è¢«ä¸»åŠ¨é‡Šæ”¾ï¼Œå¦‚ä¸€ç›´è¢«å ç”¨ï¼Œå¦‚ç¼“å­˜é¡µé¢ã€‚æ“ä½œç³»ç»Ÿéœ€è¦æä¾›é¡µé¢å›æ”¶ç®—æ³•æ¥è¿›è¡Œé¡µé¢å›æ”¶ã€‚</p>

<p>ä¸€èˆ¬æ¥è¯´ï¼Œç”¨äºé¡µç¼“å­˜çš„ç‰©ç†é¡µé¢æ— æ³•è¢«é¡µé¢çš„ä½¿ç”¨è€…ä¸»åŠ¨é‡Šæ”¾ï¼Œå› ä¸ºå®ƒä»¬ä¸çŸ¥é“è¿™äº›é¡µé¢ä½•æ—¶åº”è¯¥è¢«é‡Šæ”¾ã€‚æ“ä½œç³»ç»Ÿå†…æ ¸æœ¬èº«ä½¿ç”¨çš„ç‰©ç†é¡µé¢ä¸å†Linuxæ“ä½œç³»ç»Ÿçš„å›æ”¶èŒƒå›´ä¹‹å†…ï¼Œå®ƒä¸éœ€è¦å ç”¨å¤ªå¤šçš„å†…å­˜ã€‚</p>

<hr />

<h2 id="é¡µé¢å›æ”¶">é¡µé¢å›æ”¶</h2>
<p>Linuxçš„é¡µé¢å›æ”¶æ˜¯åŸºäºLRU(Least Recently Used,æœ€è¿‘æœ€å°‘ä½¿ç”¨)ç®—æ³•çš„ã€‚å®ƒé‡‡å–çš„ç­–ç•¥æ˜¯ï¼Œåœ¨æœ€è¿‘æ—¶é—´æ®µå†…è¢«è®¿é—®çš„æ•°æ®åœ¨ä»¥åè¢«è®¿é—®çš„æ¦‚ç‡å¤§ï¼Œè€Œä¸€ç›´æ²¡è¢«è®¿é—®çš„é¡µé¢åœ¨æœªæ¥æ¯”è¾ƒçŸ­çš„æ—¶é—´ä¹Ÿä¸ä¼šè¢«é¢‘ç¹è®¿é—®åˆ°ã€‚è¿™æ ·çš„é¡µé¢æˆä¸ºäº†é¡µé¢å›æ”¶çš„ç¬¬ä¸€é€‰æ‹©ã€‚</p>

<p>LRUç®—æ³•çš„åŸºæœ¬åŸç†å¾ˆç®€å•ï¼Œä¸ºæ¯ä¸ªç‰©ç†é¡µé¢ç»‘å®šä¸€ä¸ªè®¡æ•°å™¨ï¼Œç”¨ä»¥æ ‡è¯†è¯¥é¡µé¢çš„è®¿é—®é¢‘åº¦ã€‚æ“ä½œç³»ç»Ÿå†…æ ¸è¿›è¡Œé¡µé¢å›æ”¶çš„æ—¶å€™å°±å¯ä»¥æ ¹æ®é¡µé¢çš„è®¡æ•°å™¨çš„å€¼æ¥ç¡®å®šè¦å›æ”¶å“ªäº›é¡µé¢ã€‚ç„¶è€Œï¼Œåœ¨ç¡¬ä»¶ä¸Šæä¾›è¿™ç§æ”¯æŒçš„ä½“ç³»ç»“æ„å¾ˆå°‘ï¼ŒLinux æ“ä½œç³»ç»Ÿæ²¡æœ‰åŠæ³•ä¾é è¿™æ ·ä¸€ç§é¡µè®¡æ•°å™¨å»è·Ÿè¸ªæ¯ä¸ªé¡µé¢çš„è®¿é—®æƒ…å†µï¼Œæ‰€ä»¥ï¼ŒLinux åœ¨é¡µè¡¨é¡¹ä¸­å¢åŠ äº†ä¸€ä¸ª Accessed ä½ï¼Œå½“é¡µé¢è¢«è®¿é—®åˆ°çš„æ—¶å€™ï¼Œè¯¥ä½å°±ä¼šè¢«ç¡¬ä»¶è‡ªåŠ¨ç½®ä½ã€‚è¯¥ä½è¢«ç½®ä½è¡¨ç¤ºè¯¥é¡µé¢è¿˜å¾ˆå¹´è½»ï¼Œä¸èƒ½è¢«æ¢å‡ºå»ã€‚æ­¤åï¼Œåœ¨ç³»ç»Ÿçš„è¿è¡Œè¿‡ç¨‹ä¸­ï¼Œè¯¥é¡µé¢çš„å¹´é¾„ä¼šè¢«æ“ä½œç³»ç»Ÿæ›´æ”¹ã€‚</p>

<p>åœ¨Linux ä¸­ï¼Œæ“ä½œç³»ç»Ÿå¯¹LRUçš„å®ç°ä¸»è¦æ˜¯åŸºäºä¸€å¯¹åŒå‘é“¾è¡¨ï¼šactive é“¾è¡¨å’Œ inactive é“¾è¡¨ï¼Œè¿™ä¸¤ä¸ªé“¾è¡¨æ˜¯ Linux æ“ä½œç³»ç»Ÿè¿›è¡Œé¡µé¢å›æ”¶æ‰€ä¾èµ–çš„å…³é”®æ•°æ®ç»“æ„ï¼Œæ¯ä¸ªå†…å­˜åŒºåŸŸéƒ½å­˜åœ¨ä¸€å¯¹è¿™æ ·çš„é“¾è¡¨ã€‚</p>

<p>å…·ä½“å…³äºLinuxä¸­LRUå®ç°å‚è§[1]ã€‚</p>

<hr />

<h2 id="lruç¼“å­˜">LRUç¼“å­˜</h2>
<p>åœ¨LeetCodeä¸­æ›¾æ’åç¬¬ä¸€çš„æœ‰è¿™æ ·ä¸€ä¸ªé¢˜ï¼š</p>

<blockquote>
  <p>Design and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: get and set.</p>
</blockquote>

<blockquote>
  <p>get(key) - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.</p>
</blockquote>

<blockquote>
  <p>set(key, value) - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item.</p>
</blockquote>

<p>è¿™ä¸ªæ•°æ®ç»“æ„å°±æ˜¯æ¨¡æ‹ŸLRUç¼“å­˜çš„å®ç°ã€‚</p>

<p>æˆ‘ä»¬é‡‡å–ä¸€ä¸ªåŒå‘é“¾è¡¨ç”¨æ¥å­˜å‚¨é”®å€¼å¯¹ï¼ŒåŠ å…¥å“ˆå¸Œè¡¨å®ç°O(1)çš„æ£€ç´¢ã€‚å½“æ•°æ®è¢«ä½¿ç”¨(æˆ–è€…æ–°æ•°æ®åŠ å…¥ï¼‰æ—¶ï¼Œæ”¾åˆ°é“¾è¡¨å°¾ã€‚é“¾è¡¨å°¾è¡¨ç¤ºæœ€è¿‘è¢«ä½¿ç”¨çš„æ•°æ®ã€‚å½“æ•°æ®æº¢å‡ºï¼Œåˆ™åˆ é™¤æœªè¢«é¢‘ç¹ä½¿ç”¨çš„å¤´èŠ‚ç‚¹ã€‚</p>

<p>å…ˆè®¾è®¡è¿™æ ·ä¸€ä¸ªå­˜æ”¾é”®å€¼å¯¹çš„æ•°æ®ç»“æ„ï¼Œå…¶ä¸­åŠ å…¥äº†ç»“æ„ä½“æ„é€ å‡½æ•°ï¼Œç”¨å‚æ•°åˆ—è¡¨å°†æ‰€æœ‰çš„æ•°æ®æˆå‘˜åˆå§‹åŒ–ç½®é›¶ã€‚</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>struct LRUStruct
{
    int key;
    int value;
    LRUStruct *pre;
    LRUStruct *next;
    LRUStruct(int k=0,int v=0,LRUStruct *p=NULL,LRUStruct *n=NULL):key(k),value(v),pre(p),next(n){}
};
</code></pre></div></div>

<p>å†è®¾è®¡ä¸€ä¸ªå¤´å°¾èŠ‚ç‚¹çš„æ•°æ®ç»“æ„ï¼Œå®ƒä¸å­˜å‚¨å®é™…æ•°æ®ï¼Œåªæ˜¯ç”¨æ¥æŠŠLRUStructæ”¾åˆ°å¤´å’Œå°¾çš„ä¸­é—´ã€‚</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>struct HeadTail
{
    LRUStruct head;
    LRUStruct tail;
    HeadTail(LRUStruct h,LRUStruct t):head(h),tail(t){}
};
</code></pre></div></div>

<p>æ¥ç€å®šä¹‰LRUCacheç±»ï¼ŒåŠ å…¥unordered_mapå“ˆå¸Œè¡¨ã€‚keyä¸ºintï¼Œå¯¹åº”æ•°æ®è¾“å…¥çš„keyã€‚valueä¸ºLRUStruct*ï¼Œå¯¹åº”äºè¡¨ç¤ºæ•´ä¸ªæ•°æ®çš„ç»“æ„æŒ‡é’ˆã€‚</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class LRUCache{
public:
    int size;
    unordered_map&lt;int,LRUStruct*&gt; keyMap;
    HeadTail ht;
LRUCache(int capacity):ht(LRUStruct(),LRUStruct())
{
    size=capacity;
}
</code></pre></div></div>

<p>å½“è·å–valueæ—¶ï¼Œç”¨HashTableæ£€ç´¢ï¼Œå¦‚æœå­˜åœ¨åˆ™è¿”å›å€¼ï¼ŒåŒæ—¶å°†èŠ‚ç‚¹æ”¾åˆ°é“¾è¡¨tailèŠ‚ç‚¹çš„å‰é¢ï¼Œè¡¨ç¤ºæœ€è¿‘ä½¿ç”¨è¿‡ã€‚</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int get(int key) {
    if((keyMap.empty()) || (!keyMap.count(key))) return -1;
    LRUStruct *ls=keyMap[key];
    ls-&gt;pre-&gt;next=ls-&gt;next;
    ls-&gt;next-&gt;pre=ls-&gt;pre;
    insertTail(ls);
    return ls-&gt;value;
}
</code></pre></div></div>

<p>å½“è®¾ç½®valueæ—¶ï¼Œå¦‚æœä¸ºç©ºï¼Œåˆ™å»ºç«‹é“¾è¡¨ã€‚å¦‚æœèƒ½æ‰¾åˆ°keyï¼Œåˆ™æŠŠèŠ‚ç‚¹æ’åˆ°æœ€åã€‚å¦‚æœæ²¡æœ‰è¿™ä¸ªèŠ‚ç‚¹ï¼ŒåŒæ—¶é“¾è¡¨æœªæ»¡ï¼Œä¹ŸæŠŠèŠ‚ç‚¹æ’åˆ°æœ€åã€‚å¦‚æœæ²¡æœ‰è¿™ä¸ªèŠ‚ç‚¹ï¼ŒåŒæ—¶é“¾è¡¨å·²æ»¡ï¼Œåˆ™åˆ é™¤headä¹‹åçš„èŠ‚ç‚¹ï¼Œå°†æ–°èŠ‚ç‚¹æ’åˆ°æœ€åã€‚</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>void set(int key, int value) {
    if (keyMap.empty())
    {
        LRUStruct *ls=new LRUStruct(key,value);
        ht.head.next=ls;
        ls-&gt;pre=&amp;ht.head;
        ht.tail.pre=ls;
        ls-&gt;next=&amp;ht.tail;
        keyMap[key]=ls;
        return;
    }
    if (keyMap.count(key))
    {
        LRUStruct *ls=keyMap[key];
        ls-&gt;value=value;
        ls-&gt;pre-&gt;next=ls-&gt;next;
        ls-&gt;next-&gt;pre=ls-&gt;pre;
        insertTail(ls);
    }
    
    else
    {
        if(keyMap.size()&lt;size)
        {
            LRUStruct *ls=new LRUStruct(key,value);
            insertTail(ls);
            keyMap[key]=ls;
        }
        else
        {
            LRUStruct *p_tmp = ht.head.next;
            keyMap.erase(p_tmp-&gt;key);
            deleteHead();
            LRUStruct *ls = new LRUStruct(key,value);
            insertTail(ls);
            keyMap[key] = ls;
            delete p_tmp;
        }
    }
    
}
void insertTail(LRUStruct *ls)
{
    ls-&gt;pre=ht.tail.pre;
    ht.tail.pre-&gt;next=ls;
    ls-&gt;next=&amp;ht.tail;
    ht.tail.pre=ls;
}
   
void deleteHead()
{
    ht.head.next=ht.head.next-&gt;next;
    ht.head.next-&gt;pre=&amp;ht.head;
}
};
</code></pre></div></div>

<p>è¿™å°±æ˜¯æ•´ä¸ªLRUåŸç†å’Œç»“æ„çš„å®ç°ï¼Œåªä¸è¿‡Linuxå†…æ ¸ä¸­ä¼šæ›´å¤æ‚ä¸€äº›ã€‚</p>

<hr />

<h2 id="reference">Reference</h2>
<p>[1].http://www.ibm.com/developerworks/cn/linux/l-cn-pagerecycle/</p>

<p>[2].https://oj.leetcode.com/problems/lru-cache/</p>

<p>[3].http://my.oschina.net/lvyi/blog/346227</p>

<p>[4].http://blog.csdn.net/beiyeqingteng/article/details/7010411</p>

<p>[5].http://blog.csdn.net/zqpgood/article/details/6781195</p>

<p>[6].Understanding the Linux Kernel</p>

:ET