I"-<p>åœ¨çœ‹ä¸€ä¸ªè±†ç“£FMé¡¹ç›®çš„QTç¨‹åºã€‚é‡Œé¢ç”¨åˆ°äº†ç±»ä¼¼å•ä¾‹æ¨¡å¼ï¼ˆsingletenï¼‰çš„å®¢æˆ·ç«¯-æœåŠ¡å™¨æ–¹æ³•ï¼Œç”¨æ¥æ§åˆ¶è¯¥ç¨‹åºåªèƒ½è¿è¡Œä¸€ä¸ªå®ä¾‹è¿›ç¨‹ã€‚</p>

<hr />
<h2 id="singleten">singleten</h2>
<p>æ‰€è°“çš„å•ä¾‹æ¨¡å¼æ˜¯æŒ‡ä¸€ä¸ªç±»åªæœ‰ä¸€ä¸ªå®ä¾‹ï¼Œå¹¶æä¾›ä¸€ä¸ªè®¿é—®å®ƒçš„å…¨å±€è®¿é—®ç‚¹ï¼Œå‚è§_å¤§è¯è®¾è®¡æ¨¡å¼_ P213ã€‚</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Singleton
{
    private:
    Singleton(){}
    static Singleton *instance;
    public:
    static Singleton* GetInstance()
    {
        if(instance == NULL)
        instance = new Singleton();
        return instance;
    }
}
</code></pre></div></div>

<p>å¯ä»¥çœ‹å‡ºæ­¤ç±»çš„æ„é€ å‡½æ•°ä¸ºç§æœ‰ï¼Œå› æ­¤ä¸èƒ½ç”¨newæ¥å®ä¾‹åŒ–å¯¹è±¡ã€‚åªèƒ½é€šè¿‡é™æ€æ–¹æ³•(æ–¹æ³•è°ƒç”¨ç‹¬ç«‹äºå¯¹è±¡)ï¼š</p>

<p>` Singleton *p1 =  Singleton :: GetInstance() `</p>

<hr />
<h2 id="ä½¿ç”¨qlocalsocket">ä½¿ç”¨QLocalSocket</h2>
<p>æˆ‘ä»¬å†çœ‹ä¸€ä¸‹QTé‡Œæ˜¯é‡‡ç”¨ä»€ä¹ˆæ–¹æ³•ã€‚</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>QLocalSocket socket;//Connect to the local server
socket.connectToServer(LOCAL_SOCKET_NAME);
if (socket.waitForConnected(500)) {
        qWarning() &lt;&lt; "There is already a instance running, /
        raising it up";
        return 0;
}

QLocalServer server(&amp;w);
 w.connect(&amp;server, &amp;QLocalServer::newConnection, [&amp;] () {
     if (w.isHidden())
         w.show();
     else
         w.activateWindow();
     qDebug() &lt;&lt; "Raise window";
    }
);
server.listen(LOCAL_SOCKET_NAME);

</code></pre></div></div>

<p>è¿™é‡Œï¼Œå…ˆç”¨QLocalSocketæ–°å»ºè¿æ¥æ¥è¿æ¥æœ¬åœ°æœåŠ¡å™¨ï¼Œå¦‚æœèƒ½è¿ä¸Šï¼Œè¯´æ˜å·²ç»å­˜åœ¨æœåŠ¡å™¨ï¼Œå³æœ‰ä¸€ä¸ªå®ä¾‹è¿›ç¨‹äº†ã€‚è¿™æ—¶é€€å‡ºã€‚</p>

<p>QLocalServeråˆ™æ–°å»ºä¸€ä¸ªæœåŠ¡å™¨ï¼ŒåŒæ—¶ç›‘å¬å®¢æˆ·ç«¯æ¶ˆæ¯ã€‚</p>

<hr />

<h2 id="è¯»å†™é”æœºåˆ¶">è¯»å†™é”æœºåˆ¶</h2>
<p>åœ¨_APUE_å®ˆæŠ¤è¿›ç¨‹ä¸€èŠ‚ä¹Ÿè°ˆåˆ°äº†å½“å®ˆæŠ¤è¿›ç¨‹åªæœ‰ä¸€ä¸ªå‰¯æœ¬è¿è¡Œæ—¶,æˆ‘ä»¬å¯ä»¥è¿™æ ·åš:</p>

<blockquote>
  <p>æ¯ä¸€ä¸ªå®ˆæŠ¤è¿›ç¨‹åˆ›å»ºä¸€ä¸ªæœ‰å›ºå®šåå­—çš„æ–‡ä»¶,å¹¶åœ¨è¯¥æ–‡ä»¶æ•´ä½“ä¸ŠåŠ ä¸€æŠŠå†™é”,é‚£ä¹ˆå…åˆ›å»ºä¸€æŠŠè¿™æ ·çš„å†™é”ã€‚åœ¨æ­¤ä¹‹åˆ›å»ºå†™é”çš„å°è¯•
éƒ½ä¼šå¤±è´¥ï¼Œè¿™å‘åç»­å®ˆè¿›å‰¯æœ¬æŒ‡æ˜å·²æœ‰ä¸€ä¸ªå‰¯æœ¬æ­£åœ¨è¿è¡Œã€‚</p>
</blockquote>

<p>è‡³äºå…¶åº”ç”¨ï¼Œå¯ä»¥å‚åŠ <a href="https://github.com/zonyitoo/sysuh3c/blob/cpp0x/src/main.cpp">A SYSU H3C Client in *NIX</a>ã€‚</p>

<p>ç¤ºä¾‹å¦‚ä¸‹ï¼š</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#define LOCKFILE "/var/run/daemon.pid"
#define LOCKMODE (S_IRUSR |S_IWUSR |S_IRGRP |S_IROTH)

//extern int lockfile(int);

int already_running(void)
{
    int fd;
    char buf[16];

    fd = open(LOCKFILE, O_RDWR|O_CREAT, LOCKMODE);
    if(fd &lt; 0){
        syslog(LOG_ERR, "can't open %s: %s", LOCKFILE, strerror(errno));
        exit(1);
    }
    if(lockf(fd, F_TLOCK, 0) &lt; 0){
       // if(errno == EACCES || errno == EAGAIN){
       //     close(fd);
        syslog(LOG_ERR, "can't lock %s: %s", LOCKFILE, strerror(errno));
            return 1;
        }
    ftruncate(fd, 0);//å°†æ–‡ä»¶å¤§å°ç½®ä¸º0
    sprintf(buf, "%ld", (long)getpid());
    write(fd, buf, strlen(buf)+1);
    return 0;
}

</code></pre></div></div>

<hr />
<h2 id="reference">Reference</h2>
<p>[1].http://www.raychase.net/2556</p>

<p>[2].http://blog.csdn.net/hackbuteer1/article/details/7460019</p>

<p>[3].http://blog.csdn.net/yangxiao_0203/article/details/11492137</p>

<p>[4].APUE. Page380</p>
:ET