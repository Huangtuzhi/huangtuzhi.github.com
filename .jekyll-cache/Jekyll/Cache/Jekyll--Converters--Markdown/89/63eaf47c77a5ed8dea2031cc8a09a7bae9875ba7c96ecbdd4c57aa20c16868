I"|<p>å¼€å§‹ç»ƒä¹ LeetCodeä¸Šçš„åŸºç¡€ç®—æ³•é¢˜ã€‚LeeCodeæ”¯æŒ3ç§è¯­è¨€ï¼špythonï¼ŒC++ï¼ŒJavaï¼ŒC++å»ºè®®ä½¿ç”¨STLã€‚</p>

<hr />

<h2 id="pascals-triangle">Pascalâ€™s Triangle</h2>

<p>Given numRows, generate the first numRows of Pascalâ€™s triangle.For example, given numRows = 5,Return</p>

<p>1</p>

<p>1 1</p>

<p>1 2 1</p>

<p>1 3 3 1</p>

<p>1 4 6 4 1</p>

<p>æ€è·¯ï¼šé¡ºåºåŠ å…¥æ¯ä¸€ä¸ªvectorã€‚æ˜¾ç„¶æ¯ä¸ªvectorçš„å¤§å°ä¸ä¸€æ ·ã€‚</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Solution {
public:
vector&lt;vector&lt;int&gt; &gt; generate(int numRows)
{
    vector&lt;vector&lt;int&gt; &gt; answer;
    for(int i=0;i&lt; numRows;i++)
    {
        vector&lt;int&gt; col;
        if(i==0)
        col.push_back(1);
        else
        {
            for(int j=0;j&lt;=i;j++)
            {
                if(j==0 || j==i)
                col.push_back(1);
                else
                col.push_back(answer[i-1][j]+answer[i-1][j-1]);
             }
            }
        answer.push_back(col);
        }
    return answer;
    }
};
</code></pre></div></div>

<hr />

<h2 id="same-tree">Same Tree</h2>

<p>Given two binary trees, write a function to check if they are equal or not.
Two binary trees are considered equal if they are structurally identical and the nodes have the same value.</p>

<p>æ€è·¯ï¼šé‡‡ç”¨é€’å½’ï¼Œåˆ†åˆ«åˆ¤åˆ«å·¦èŠ‚ç‚¹å’Œå³èŠ‚ç‚¹ï¼Œä¸¤è¾¹èŠ‚ç‚¹éƒ½æ»¡è¶³æ—¶æ‰è¿”å›trueã€‚</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/**
* Definition for binary tree
* struct TreeNode {
*     int val;
*     TreeNode *left;
*     TreeNode *right;
*     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
* };
*/
class Solution {
public:
    bool isSameTree(TreeNode *p, TreeNode *q) {
    if( (!p)&amp;&amp;(!q) )
    return true;
    if( (!p&amp;&amp;q) || (p&amp;&amp;!q) || (p-&gt;val != q-&gt;val) )
    return false;
    return( isSameTree(p-&gt;left, q-&gt;left) &amp;&amp; isSameTree(p-&gt;right, q-&gt;right) );
    }
};
</code></pre></div></div>

<hr />

<h2 id="min-stack">Min Stack</h2>

<p>Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.</p>

<p>push(x) â€“ Push element x onto stack.</p>

<p>pop() â€“ Removes the element on top of the stack.</p>

<p>top() â€“ Get the top element.</p>

<p>getMin() â€“ Retrieve the minimum element in the stack.</p>

<p>æ€è·¯ï¼šå› ä¸ºé¢˜ç›®è¦æ±‚retrieving the minimum element in constant timeï¼Œæ‰€ä»¥ä¸èƒ½å¯¹å †æ ˆæ•´ä¸ªè¿›è¡Œæœç´¢ã€‚å¿…é¡»å¦ç”¨ä¸€ä¸ªå †æ ˆæ¥è®°å½•æœ€å°çš„å…ƒç´ ã€‚</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class MinStack {
public:
void push(int x) {
    elements.push(x);
    if ( mins.empty() || x&lt;=mins.top() )
    mins.push(x);
}

void pop() {
    if ( elements.empty() )
    return;
    if(elements.top()==mins.top())
    mins.pop();
    elements.pop();
    
}

int top() {
    return elements.top();
}

int getMin() {
    return mins.top();
}


private:
stack &lt;int&gt; elements;
stack &lt;int&gt; mins;
};
</code></pre></div></div>

<hr />

<h2 id="sqrtx">Sqrt(x)</h2>

<p>Implement int sqrt(int x).Compute and return the square root of x.</p>

<p>æ€è·¯ï¼šäºŒåˆ†æ³•ï¼Œæ³¨æ„äºŒåˆ†çš„æ—¶å€™ä¸èƒ½æº¢å‡ºï¼Œä¸ºäº†åŠ å¿«è¿ç®—é€Ÿåº¦é‡‡ç”¨ç§»ä½æ“ä½œç¬¦ã€‚</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Solution {
public:
    int sqrt(int x) {
    int low=1,high=x,mid;
    if(x&lt;=1) return x;
    while(low&lt;=high)
        {
        mid=low+((high-low)&gt;&gt;1);
        if(mid==x/mid) return mid;
        if(mid&gt;x/mid)
        {
            high=mid-1;
        }
        else low=mid+1;
        }
     return high;
    }
};
</code></pre></div></div>

<hr />

<h2 id="reference">Reference</h2>

<p>[1].https://oj.leetcode.com/</p>

:ET