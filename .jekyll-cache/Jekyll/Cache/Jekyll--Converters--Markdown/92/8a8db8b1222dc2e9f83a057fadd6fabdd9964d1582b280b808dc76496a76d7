I"<p><strong>RAII</strong>ï¼ŒæŒ‡çš„æ˜¯Resource Acquisition is Initializationã€‚å³ä½¿ç”¨èµ„æºæ—¶å¯¹èµ„æºåˆå§‹åŒ–ï¼Œä½¿ç”¨å®Œæ¯•è¿›è¡Œè‡ªåŠ¨é‡Šæ”¾ã€‚å®ƒåˆ©ç”¨stackä¸Šçš„ä¸´æ—¶å¯¹è±¡ç”Ÿå‘½æœŸæ˜¯ç¨‹åºè‡ªåŠ¨ç®¡ç†çš„è¿™ä¸€ç‰¹ç‚¹ï¼Œå°†æˆ‘ä»¬çš„èµ„æºé‡Šæ”¾æ“ä½œå°è£…åœ¨ä¸€ä¸ªä¸´æ—¶å¯¹è±¡ä¸­ã€‚</p>

<p>å½“æˆ‘ä»¬ä½¿ç”¨å¤šçº¿ç¨‹æ—¶ï¼Œéœ€è¦ä¿è¯çº¿ç¨‹å®‰å…¨ï¼Œè¿™å°±éœ€è¦å¯¹èµ„æºè¿›è¡ŒåŠ é”ã€‚Linuxä¸‹ä½¿ç”¨<code class="language-plaintext highlighter-rouge">pthread_mutex_t</code>å®ç°ä¸å¯é‡å…¥ã€‚æˆ‘ä»¬å¯ä»¥ç”¨RAIIçš„æ‰‹æ³•å¯¹mutexè¿›è¡Œå°è£…ã€‚</p>

<hr />

<h2 id="å°è£…">å°è£…</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class MutexLock
{
public:
	MutexLock() {
		pthread_mutex_init(&amp;mutex_, NULL);
        cout &lt;&lt; "construct of MutexLock" &lt;&lt; endl;
	}
	~MutexLock() {
		cout &lt;&lt; "deconstruct of MutexLock" &lt;&lt; endl;
		pthread_mutex_destroy(&amp;mutex_);
	}

	void lock() {
		pthread_mutex_lock(&amp;mutex_);//lockä¸ä¸Šçš„çº¿ç¨‹ä¼šè¢«é˜»å¡
	}

	void unlock() {
		pthread_mutex_unlock(&amp;mutex_);
	}

private:
	MutexLock(const MutexLock &amp;);
	MutexLock&amp; operator=(const MutexLock &amp;); 

	pthread_mutex_t mutex_;
};

class MutexLockGuard
{
public:
	explicit MutexLockGuard(MutexLock &amp;mutex): mutex_(mutex) {
        cout &lt;&lt; "construct of MutexLockGuard" &lt;&lt; endl;
		mutex_.lock();
	}
	~MutexLockGuard() {
		cout &lt;&lt; "deconstruct of MutexLockGuard" &lt;&lt; endl;
		mutex_.unlock();
	}

private:
	MutexLockGuard(const MutexLock &amp;);
	MutexLockGuard&amp; operator=(const MutexLock &amp;);
	MutexLock &amp;mutex_;
};
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">MutexLock</code>ç±»çš„æ„é€ å‡½æ•°åˆå§‹åŒ–äº’æ–¥é”ï¼Œææ„å‡½æ•°é”€æ¯äº’æ–¥é”ã€‚å®ƒå°è£…äº†ä¸´ç•ŒåŒºï¼Œä½äº<code class="language-plaintext highlighter-rouge">lock()</code>å’Œ<code class="language-plaintext highlighter-rouge">unlock()</code>è°ƒç”¨ä¹‹é—´ã€‚</p>

<p><code class="language-plaintext highlighter-rouge">MutexLockGuard</code>ç±»çš„æ„é€ å‡½æ•°å¯¹ä¸´ç•ŒåŒºè¿›è¡ŒåŠ é”æ“ä½œï¼Œè¿›å…¥ä¸´ç•ŒåŒºï¼Œä¿è¯äº†ä¸å¯é‡å…¥ã€‚ææ„å‡½æ•°è§£é”ï¼Œé€€å‡ºä¸´ç•ŒåŒºã€‚</p>

<p><code class="language-plaintext highlighter-rouge">MutexLockGuard</code>ç±»ä¸€èˆ¬æ˜¯ä¸€ä¸ªæ ˆå¯¹è±¡ï¼Œå®ƒçš„ä½œç”¨åŸŸåˆšå¥½ç­‰äºä¸´ç•ŒåŒºåŸŸã€‚</p>

<hr />

<h2 id="åº”ç”¨">åº”ç”¨</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
MutexLock mutex;
int cnt = 5;

void *f(void *arg){
    long t_num = (long) arg;
    while(true){
        MutexLockGuard lock(mutex);
        if(cnt&gt;0){
            usleep(1);
            cout &lt;&lt; "args: " &lt;&lt; t_num &lt;&lt; " "&lt; "cnt: "&lt;&lt; cnt--&lt;&lt; endl; 
        } 
        else{break;}       
    }
    return NULL;
}

int main()
{
    pthread_t tid, tid1, tid2, tid3;
    int ret = pthread_create(&amp;tid, NULL, f,(void*)11);
    if(ret == -1){
        perror("create error\n");
    }
     
    ret = pthread_create(&amp;tid1, NULL, f, (void*)22);
    if(ret == -1){
        perror("create error\n");
    }
     
    ret = pthread_create(&amp;tid2, NULL, f, (void*)33);
    if(ret == -1){
        perror("create error\n");
    }
     
    ret = pthread_create(&amp;tid3, NULL, f, (void*)44);
    if(ret == -1){
        perror("create error\n");
    }
     
    pthread_join(tid, NULL);
    pthread_join(tid1, NULL);
    pthread_join(tid2, NULL);
    pthread_join(tid3, NULL);
    return 0;
}
</code></pre></div></div>

<p>ç¨‹åºæ‰“å¼€å››ä¸ªçº¿ç¨‹è¿›è¡Œæµ‹è¯•ï¼Œæ‰“å°ç»“æœå¦‚ä¸‹ï¼š</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>construct of MutexLock
construct of MutexLockGuard

construct of MutexLockGuard
args: 11 cnt: 5
deconstruct of MutexLockGuard

construct of MutexLockGuard
construct of MutexLockGuard

construct of MutexLockGuard
args: 11 cnt: 4
deconstruct of MutexLockGuard

construct of MutexLockGuard
args: 11 cnt: 3
deconstruct of MutexLockGuard

construct of MutexLockGuard
args: 33 cnt: 2
deconstruct of MutexLockGuard

construct of MutexLockGuard
args: 33 cnt: 1
deconstruct of MutexLockGuard

construct of MutexLockGuard
deconstruct of MutexLockGuard

deconstruct of MutexLockGuard
deconstruct of MutexLockGuard
deconstruct of MutexLockGuard
deconstruct of MutexLock
</code></pre></div></div>

<p>è¿™ä¸ªç»“æœæœ‰ç‚¹è¯¡å¼‚ã€‚å½“å››ä¸ªçº¿ç¨‹åˆå§‹åŒ–æ—¶ï¼Œç”Ÿæˆäº†ä¸¤ä¸ª<code class="language-plaintext highlighter-rouge">MutexLockGuard</code>å®ä¾‹ã€‚å…¶ä¸­ä¸€ä¸ªè·å–åˆ°äº†mutexé”ï¼Œå¦ä¸€ä¸ªè¿›ç¨‹é˜»å¡ã€‚å¯¹<code class="language-plaintext highlighter-rouge">cnt</code>è¿›è¡Œæ“ä½œåï¼Œé‡Šæ”¾äº†mutexé”ã€‚</p>

<p>ç„¶åä¸»çº¿ç¨‹ç»§ç»­ç”Ÿæˆå¦å¤–ä¸¤ä¸ª<code class="language-plaintext highlighter-rouge">MutexLockGuard</code>å®ä¾‹ã€‚ä¸»çº¿ç¨‹æœªç›´æ¥ç”Ÿæˆå››ä¸ªå®ä¾‹æ˜¯å› ä¸º</p>

<blockquote>
  <p>The main() thread is possibly not creating all threads before it gets preempted by one of its child threads.</p>
</blockquote>

<p>æ¥ä¸‹æ¥å‘ç”Ÿçš„äº‹æ˜¯:</p>

<p><code class="language-plaintext highlighter-rouge">args: 11</code>è·å–é”ï¼Œé‡Šæ”¾é”ï¼Œ<code class="language-plaintext highlighter-rouge">cnt--</code></p>

<p><code class="language-plaintext highlighter-rouge">args: 11</code>è·å–é”ï¼Œé‡Šæ”¾é”ï¼Œ<code class="language-plaintext highlighter-rouge">cnt--</code></p>

<p><code class="language-plaintext highlighter-rouge">args: 33</code>è·å–é”ï¼Œé‡Šæ”¾é”ï¼Œ<code class="language-plaintext highlighter-rouge">cnt--</code></p>

<p><code class="language-plaintext highlighter-rouge">args: 33</code>è·å–é”ï¼Œé‡Šæ”¾é”ï¼Œ<code class="language-plaintext highlighter-rouge">cnt--</code></p>

<p>æŸä¸ªè¿›ç¨‹æ‰§è¡Œbreakç»“æŸå¾ªç¯ã€‚</p>

<p>å…·ä½“å¯ä»¥å‚è§<a href="http://stackoverflow.com/questions/30678529/constructor-and-destructor-in-multi-threading">OS</a>è®¨è®ºã€‚</p>

<blockquote>
  <p>All the threads construct a MutexLockGuard but only one is permitted to acquire the mutex and proceed (as intended).</p>
</blockquote>

<blockquote>
  <p>However, when that one destroys its MutexLockGuard and releases the mutex, it turns out that it loops around and creates a new MutexLockGuard and acquires the mutex before the system unblocks another thread and allows them to acquire the mutex.</p>
</blockquote>

<blockquote>
  <p>Mutex acquisition is not guaranteed to be fair. The system may act like this in an attempt to prevent spending work switching threads.</p>
</blockquote>

<p>å…¶å®äº‰æŠ¢åˆ°mutexçš„çº¿ç¨‹ä¸­å±€éƒ¨å˜é‡<code class="language-plaintext highlighter-rouge">MutexLockGuard</code>å®ä¾‹çš„ç”Ÿå­˜æœŸä½äº<code class="language-plaintext highlighter-rouge">while</code>ä¸­ï¼Œå…¶å®ƒæœªäº‰æŠ¢åˆ°mutexçš„çº¿ç¨‹é˜»å¡æ²¡æœ‰æ‰§è¡Œåˆ°ä¸‹ä¸€ä¸ª<code class="language-plaintext highlighter-rouge">while</code>ï¼Œæ‰€ä»¥ä¸è°ƒç”¨ææ„å‡½æ•°ã€‚</p>

<p>å½“æ‰€æœ‰å±€éƒ¨çš„<code class="language-plaintext highlighter-rouge">MutexLockGuard</code>ææ„åï¼Œå…¨å±€çš„<code class="language-plaintext highlighter-rouge">MutexLock</code>åœ¨æœ€åè‡ªåŠ¨ææ„ã€‚</p>

<hr />

<h2 id="å‚è€ƒ">å‚è€ƒ</h2>

<p>Linuxå¤šçº¿ç¨‹æœåŠ¡ç«¯ç¼–ç¨‹</p>
:ET