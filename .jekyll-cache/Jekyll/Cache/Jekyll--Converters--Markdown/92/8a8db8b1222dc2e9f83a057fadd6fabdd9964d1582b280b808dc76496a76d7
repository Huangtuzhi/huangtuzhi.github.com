I"<p><strong>RAII</strong>，指的是Resource Acquisition is Initialization。即使用资源时对资源初始化，使用完毕进行自动释放。它利用stack上的临时对象生命期是程序自动管理的这一特点，将我们的资源释放操作封装在一个临时对象中。</p>

<p>当我们使用多线程时，需要保证线程安全，这就需要对资源进行加锁。Linux下使用<code class="language-plaintext highlighter-rouge">pthread_mutex_t</code>实现不可重入。我们可以用RAII的手法对mutex进行封装。</p>

<hr />

<h2 id="封装">封装</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class MutexLock
{
public:
	MutexLock() {
		pthread_mutex_init(&amp;mutex_, NULL);
        cout &lt;&lt; "construct of MutexLock" &lt;&lt; endl;
	}
	~MutexLock() {
		cout &lt;&lt; "deconstruct of MutexLock" &lt;&lt; endl;
		pthread_mutex_destroy(&amp;mutex_);
	}

	void lock() {
		pthread_mutex_lock(&amp;mutex_);//lock不上的线程会被阻塞
	}

	void unlock() {
		pthread_mutex_unlock(&amp;mutex_);
	}

private:
	MutexLock(const MutexLock &amp;);
	MutexLock&amp; operator=(const MutexLock &amp;); 

	pthread_mutex_t mutex_;
};

class MutexLockGuard
{
public:
	explicit MutexLockGuard(MutexLock &amp;mutex): mutex_(mutex) {
        cout &lt;&lt; "construct of MutexLockGuard" &lt;&lt; endl;
		mutex_.lock();
	}
	~MutexLockGuard() {
		cout &lt;&lt; "deconstruct of MutexLockGuard" &lt;&lt; endl;
		mutex_.unlock();
	}

private:
	MutexLockGuard(const MutexLock &amp;);
	MutexLockGuard&amp; operator=(const MutexLock &amp;);
	MutexLock &amp;mutex_;
};
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">MutexLock</code>类的构造函数初始化互斥锁，析构函数销毁互斥锁。它封装了临界区，位于<code class="language-plaintext highlighter-rouge">lock()</code>和<code class="language-plaintext highlighter-rouge">unlock()</code>调用之间。</p>

<p><code class="language-plaintext highlighter-rouge">MutexLockGuard</code>类的构造函数对临界区进行加锁操作，进入临界区，保证了不可重入。析构函数解锁，退出临界区。</p>

<p><code class="language-plaintext highlighter-rouge">MutexLockGuard</code>类一般是一个栈对象，它的作用域刚好等于临界区域。</p>

<hr />

<h2 id="应用">应用</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
MutexLock mutex;
int cnt = 5;

void *f(void *arg){
    long t_num = (long) arg;
    while(true){
        MutexLockGuard lock(mutex);
        if(cnt&gt;0){
            usleep(1);
            cout &lt;&lt; "args: " &lt;&lt; t_num &lt;&lt; " "&lt; "cnt: "&lt;&lt; cnt--&lt;&lt; endl; 
        } 
        else{break;}       
    }
    return NULL;
}

int main()
{
    pthread_t tid, tid1, tid2, tid3;
    int ret = pthread_create(&amp;tid, NULL, f,(void*)11);
    if(ret == -1){
        perror("create error\n");
    }
     
    ret = pthread_create(&amp;tid1, NULL, f, (void*)22);
    if(ret == -1){
        perror("create error\n");
    }
     
    ret = pthread_create(&amp;tid2, NULL, f, (void*)33);
    if(ret == -1){
        perror("create error\n");
    }
     
    ret = pthread_create(&amp;tid3, NULL, f, (void*)44);
    if(ret == -1){
        perror("create error\n");
    }
     
    pthread_join(tid, NULL);
    pthread_join(tid1, NULL);
    pthread_join(tid2, NULL);
    pthread_join(tid3, NULL);
    return 0;
}
</code></pre></div></div>

<p>程序打开四个线程进行测试，打印结果如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>construct of MutexLock
construct of MutexLockGuard

construct of MutexLockGuard
args: 11 cnt: 5
deconstruct of MutexLockGuard

construct of MutexLockGuard
construct of MutexLockGuard

construct of MutexLockGuard
args: 11 cnt: 4
deconstruct of MutexLockGuard

construct of MutexLockGuard
args: 11 cnt: 3
deconstruct of MutexLockGuard

construct of MutexLockGuard
args: 33 cnt: 2
deconstruct of MutexLockGuard

construct of MutexLockGuard
args: 33 cnt: 1
deconstruct of MutexLockGuard

construct of MutexLockGuard
deconstruct of MutexLockGuard

deconstruct of MutexLockGuard
deconstruct of MutexLockGuard
deconstruct of MutexLockGuard
deconstruct of MutexLock
</code></pre></div></div>

<p>这个结果有点诡异。当四个线程初始化时，生成了两个<code class="language-plaintext highlighter-rouge">MutexLockGuard</code>实例。其中一个获取到了mutex锁，另一个进程阻塞。对<code class="language-plaintext highlighter-rouge">cnt</code>进行操作后，释放了mutex锁。</p>

<p>然后主线程继续生成另外两个<code class="language-plaintext highlighter-rouge">MutexLockGuard</code>实例。主线程未直接生成四个实例是因为</p>

<blockquote>
  <p>The main() thread is possibly not creating all threads before it gets preempted by one of its child threads.</p>
</blockquote>

<p>接下来发生的事是:</p>

<p><code class="language-plaintext highlighter-rouge">args: 11</code>获取锁，释放锁，<code class="language-plaintext highlighter-rouge">cnt--</code></p>

<p><code class="language-plaintext highlighter-rouge">args: 11</code>获取锁，释放锁，<code class="language-plaintext highlighter-rouge">cnt--</code></p>

<p><code class="language-plaintext highlighter-rouge">args: 33</code>获取锁，释放锁，<code class="language-plaintext highlighter-rouge">cnt--</code></p>

<p><code class="language-plaintext highlighter-rouge">args: 33</code>获取锁，释放锁，<code class="language-plaintext highlighter-rouge">cnt--</code></p>

<p>某个进程执行break结束循环。</p>

<p>具体可以参见<a href="http://stackoverflow.com/questions/30678529/constructor-and-destructor-in-multi-threading">OS</a>讨论。</p>

<blockquote>
  <p>All the threads construct a MutexLockGuard but only one is permitted to acquire the mutex and proceed (as intended).</p>
</blockquote>

<blockquote>
  <p>However, when that one destroys its MutexLockGuard and releases the mutex, it turns out that it loops around and creates a new MutexLockGuard and acquires the mutex before the system unblocks another thread and allows them to acquire the mutex.</p>
</blockquote>

<blockquote>
  <p>Mutex acquisition is not guaranteed to be fair. The system may act like this in an attempt to prevent spending work switching threads.</p>
</blockquote>

<p>其实争抢到mutex的线程中局部变量<code class="language-plaintext highlighter-rouge">MutexLockGuard</code>实例的生存期位于<code class="language-plaintext highlighter-rouge">while</code>中，其它未争抢到mutex的线程阻塞没有执行到下一个<code class="language-plaintext highlighter-rouge">while</code>，所以不调用析构函数。</p>

<p>当所有局部的<code class="language-plaintext highlighter-rouge">MutexLockGuard</code>析构后，全局的<code class="language-plaintext highlighter-rouge">MutexLock</code>在最后自动析构。</p>

<hr />

<h2 id="参考">参考</h2>

<p>Linux多线程服务端编程</p>
:ET